 (define eval_expr
  (lambda (exp env)
    (cond ((number? exp) exp)
      ((variable? exp env) (cadr (assoc exp (car env))) )
      ((condExpr? exp env)
      (eval_expr (subexp1 exp) env)
      (eval_expr (subexp2 exp) env) )
      ((fcall? exp env) (eval_expr 
  ;grabbing the expression
  (cadr (cadr (assoc (cadr (assoc (cadr exp) (car env))) (cadr env)))) 
  
  ;creating a binding btw parameter and value passed
  (eval_defs (cons (list 'vdef 
  (caar (cadr (assoc (cadr (assoc (cadr exp) (car env))) (cadr env))))
  (eval_expr (caddr exp) '())) '()) env))) 
  ((sum? exp)
      (+ (eval_expr (subexp1 exp) env)
      (eval_expr (subexp2 exp) env)))
  ((difference? exp)
      (- (eval_expr (subexp1 exp) env)
      (eval_expr (subexp2 exp) env)))
  ((product? exp)
      (* (eval_expr (subexp1 exp) env)
      (eval_expr (subexp2 exp) env)))
  ((quotient? exp)
      (/ (eval_expr (subexp1 exp) env)
      (eval_expr (subexp2 exp) env)))
 
  (else (error 'eval_expr ""invalid expression ~s"" exp)
  ))))
 
 (define fcall?
  (lambda (exp env) (eq? (car exp) 'fcall ) ))
 
 
 
 ;; The following functions test the operation of arithmetic expressions
 
 (define sum?
  (lambda (exp) (eq? (cadr exp) '+)))
 
 (define difference?
  (lambda (exp) (eq? (cadr exp) '-)))
 
 (define product?
  (lambda (exp) (eq? (cadr exp) '*)))
 
 (define quotient?
  (lambda (exp) (eq? (cadr exp) '/)))
 
 (define variable?
  (lambda (exp env) (contains? '(a b c d e f g h i g k l m n o p q r s t u v w x y z) exp)
  ))
 
 
 (define (contains? l i)
  (cond
  ((eq? l '()) #f)
  ((eq? (car l) i) #t)
  (else (contains? (cdr l) i)))
  )
 
 (define (condExpr? exp env)
  (cond ((eq? 'if (car exp)) #t)
  (else #f) ))
 
 
 ;; The following are functions to retrieve the appropriate subexpressions
 ;; from an arithmetic expression
 
 (define subexp1
  (lambda (exp) (caddr exp)))
 
 (define subexp2
  (lambda (exp) (cadddr exp)))
 
 
 ;;; Bring in the parse tree and then evaluate it
 ;;; The parse tree has two parts:
 ;;; def_part -- this is the list of definitions
 ;;; exp_part -- this is the expression after all the definitions
 
 (define compute
  (lambda ()
  (load ""scheme_ast"") ;; << This needs to be consistent
  ;; << with the file generated by ast.exe
  (let ((environment (def_part ptree)))
  (eval_expr (exp_part ptree)))))
 
 (define def_part
  (lambda (ptree) (cadr ptree)))
 
 (define exp_part
  (lambda (ptree) (caddr ptree)))
 
 (define eval_bool
  (lambda (exp env)
  (cond
  ;((eq? exp) (== (eval_expr (subexp1 exp)) (eval_expr (subexp2 exp)) ))
  ((le? exp) (< (eval_expr (subexp1 exp) env) (eval_expr (subexp2 exp) env) ))
  ((leq? exp) (<= (eval_expr (subexp1 exp) env) (eval_expr (subexp2 exp) env) ))
  ((ge? exp) (> (eval_expr (subexp1 exp) env) (eval_expr (subexp2 exp) env) ))
  ((geq? exp) (>= (eval_expr (subexp1 exp) env) (eval_expr (subexp2 exp) env) ))
  ((neq? exp) (!= (eval_expr (subexp1 exp) env) (eval_expr (subexp2 exp) env) ))
  )))
 
  ;(define eq?
  ; (lambda (exp) (eq? (cadr exp) 'eq)))
 
  (define le?
  (lambda (exp) (eq? (cadr exp) 'le)))
 
  (define leq?
  (lambda (exp) (eq? (cadr exp) 'leq)))
 
  (define ge?
  (lambda (exp) (eq? (cadr exp) 'ge)))
 
  (define geq?
  (lambda (exp) (eq? (cadr exp) 'geq)))
 
  (define neq?
  (lambda (exp) (eq? (cadr exp) 'neq)))
 
 ;; eval_def creates the binding for a single definition
 (define eval_def
  (lambda (def env)
  (cond ((vdef? def) (list (list (cadr def) (eval_expr (caddr def) env)) '()))
  ((fdef? def) (let ((ref (gensym cadr def))) 
  (cons 
  (cons (cadr def) (list ref)) ;first assoc list 
  (cons 
  (cons ref 
  (cons (cons (caddr def) (list (cadddr def) 
  (cons (cons (cadr def) (list ref))(car env)))) '())) '())
  ))
  ) 
  (else (error """"unknown definition type"""" def)))
  ))
 
 ;; eval_defs loops through multiple definitions, calling eval_def
 ;; for each, and collects all the bindings into a list.
 (define eval_defs
  (lambda (defs env)
  (if (null? defs) env
  (let ((new_binding (eval_def (car defs) env)))
  (eval_defs (cdr defs) (merge new_binding env))))
 ))
 
 (define merge
  (lambda (new_binding env)
  (list (cons (car new_binding) (car env))
  (if (null? (cadr new_binding)) (cadr env) (cons (cadr new_binding) (cadr env))))))
 
 (define vdef?
  (lambda (exp env) (eq? (car exp) 'vdef ) ))
 
 (define fdef?
  (lambda (exp env) (eq? (car exp) 'fdef ) ))
